/*
 *
 * (C) COPYRIGHT 2015-2019 ARM Limited. All rights reserved.
 *
 * This program is free software and is provided to you under the terms of the
 * GNU General Public License version 2 as published by the Free Software
 * Foundation, and any use by you of this program is subject to the terms
 * of such GNU licence.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, you can access it online at
 * http://www.gnu.org/licenses/gpl-2.0.html.
 *
 * SPDX-License-Identifier: GPL-2.0
 *
 */

#if !defined(_KBASE_TLSTREAM_H)
#define _KBASE_TLSTREAM_H

#include <mali_kbase.h>
#include <mali_kbase_gator.h>

#include <linux/typecheck.h>

/*****************************************************************************/

struct kbase_timeline;

/**
 * kbase_tlstream_init - initialize timeline infrastructure in kernel
 * @timeline:            Newly created instance of kbase_timeline will
 *                       be stored in this pointer.
 * @timeline_is_enabled: Timeline status will be written to this variable
 *                       when a client is attached/detached. The variable
 *                       must be valid while timeline instance is valid.
 * Return: zero on success, negative number on error
 */
int kbase_tlstream_init(struct kbase_timeline **timeline,
	atomic_t *timeline_is_enabled);

/**
 * kbase_tlstream_term - terminate timeline infrastructure in kernel
 *
 * @timeline:     Timeline instance to be terminated. It must be previously created
 *                with kbase_tlstream_init().
 */
void kbase_tlstream_term(struct kbase_timeline *timeline);

/**
 * kbase_tlstream_acquire - acquire timeline stream file descriptor
 * @kbdev:     Kbase device
 * @flags:     Timeline stream flags
 *
 * This descriptor is meant to be used by userspace timeline to gain access to
 * kernel timeline stream. This stream is later broadcasted by user space to the
 * timeline client.
 * Only one entity can own the descriptor at any given time. Descriptor shall be
 * closed if unused. If descriptor cannot be obtained (i.e. when it is already
 * being used) return will be a negative value.
 *
 * Return: file descriptor on success, negative number on error
 */
int kbase_tlstream_acquire(struct kbase_device *kbdev, u32 flags);

/**
 * kbase_tlstream_flush_streams - flush timeline streams.
 * @timeline:     Timeline instance
 *
 * Function will flush pending data in all timeline streams.
 */
void kbase_tlstream_flush_streams(struct kbase_timeline *timeline);

/**
 * kbase_tlstream_reset_body_streams - reset timeline body streams.
 *
 * Function will discard pending data in all timeline body streams.
 * @timeline:     Timeline instance
 */
void kbase_tlstream_reset_body_streams(struct kbase_timeline *timeline);

#if MALI_UNIT_TEST
/**
 * kbase_tlstream_test - start timeline stream data generator
 * @kbdev:     Kernel common context
 * @tpw_count: Number of trace point writers in each context
 * @msg_delay: Time delay in milliseconds between trace points written by one
 *             writer
 * @msg_count: Number of trace points written by one writer
 * @aux_msg:   If non-zero aux messages will be included
 *
 * This test starts a requested number of asynchronous writers in both IRQ and
 * thread context. Each writer will generate required number of test
 * tracepoints (tracepoints with embedded information about writer that
 * should be verified by user space reader). Tracepoints will be emitted in
 * all timeline body streams. If aux_msg is non-zero writer will also
 * generate not testable tracepoints (tracepoints without information about
 * writer). These tracepoints are used to check correctness of remaining
 * timeline message generating functions. Writer will wait requested time
 * between generating another set of messages. This call blocks until all
 * writers finish.
 */
void kbase_tlstream_test(
	struct kbase_device *kbdev,
	unsigned int tpw_count,
	unsigned int msg_delay,
	unsigned int msg_count,
	int          aux_msg);

/**
 * kbase_tlstream_stats - read timeline stream statistics
 * @timeline:        Timeline instance
 * @bytes_collected: Will hold number of bytes read by the user
 * @bytes_generated: Will hold number of bytes generated by trace points
 */
void kbase_tlstream_stats(struct kbase_timeline *timeline, u32 *bytes_collected, u32 *bytes_generated);
#endif /* MALI_UNIT_TEST */

/*****************************************************************************/

#define TL_ATOM_STATE_IDLE 0
#define TL_ATOM_STATE_READY 1
#define TL_ATOM_STATE_DONE 2
#define TL_ATOM_STATE_POSTED 3

/* We want these values to match */
#define TL_JS_EVENT_START     GATOR_JOB_SLOT_START
#define TL_JS_EVENT_STOP      GATOR_JOB_SLOT_STOP
#define TL_JS_EVENT_SOFT_STOP GATOR_JOB_SLOT_SOFT_STOPPED

void __kbase_tlstream_tl_summary_new_ctx(struct kbase_timeline *tl, void *context, u32 nr, u32 tgid);
void __kbase_tlstream_tl_summary_new_gpu(struct kbase_timeline *tl, void *gpu, u32 id, u32 core_count);
void __kbase_tlstream_tl_summary_new_lpu(struct kbase_timeline *tl, void *lpu, u32 nr, u32 fn);
void __kbase_tlstream_tl_summary_lifelink_lpu_gpu(struct kbase_timeline *tl, void *lpu, void *gpu);
void __kbase_tlstream_tl_summary_new_as(struct kbase_timeline *tl, void *as, u32 nr);
void __kbase_tlstream_tl_summary_lifelink_as_gpu(struct kbase_timeline *tl, void *as, void *gpu);
void __kbase_tlstream_tl_new_ctx(struct kbase_timeline *tl, void *context, u32 nr, u32 tgid);
void __kbase_tlstream_tl_new_atom(struct kbase_timeline *tl, void *atom, u32 nr);
void __kbase_tlstream_tl_del_ctx(struct kbase_timeline *tl, void *context);
void __kbase_tlstream_tl_del_atom(struct kbase_timeline *tl, void *atom);
void __kbase_tlstream_tl_ret_ctx_lpu(struct kbase_timeline *tl, void *context, void *lpu);
void __kbase_tlstream_tl_ret_atom_ctx(struct kbase_timeline *tl, void *atom, void *context);
void __kbase_tlstream_tl_ret_atom_lpu(struct kbase_timeline *tl,
	void *atom, void *lpu, const char *attrib_match_list);
void __kbase_tlstream_tl_nret_ctx_lpu(struct kbase_timeline *tl, void *context, void *lpu);
void __kbase_tlstream_tl_nret_atom_ctx(struct kbase_timeline *tl, void *atom, void *context);
void __kbase_tlstream_tl_nret_atom_lpu(struct kbase_timeline *tl, void *atom, void *lpu);
void __kbase_tlstream_tl_ret_as_ctx(struct kbase_timeline *tl, void *as, void *ctx);
void __kbase_tlstream_tl_nret_as_ctx(struct kbase_timeline *tl, void *as, void *ctx);
void __kbase_tlstream_tl_ret_atom_as(struct kbase_timeline *tl, void *atom, void *as);
void __kbase_tlstream_tl_nret_atom_as(struct kbase_timeline *tl, void *atom, void *as);
void __kbase_tlstream_tl_dep_atom_atom(struct kbase_timeline *tl, void *atom1, void *atom2);
void __kbase_tlstream_tl_ndep_atom_atom(struct kbase_timeline *tl, void *atom1, void *atom2);
void __kbase_tlstream_tl_rdep_atom_atom(struct kbase_timeline *tl, void *atom1, void *atom2);
void __kbase_tlstream_tl_attrib_atom_config(struct kbase_timeline *tl,
	void *atom, u64 jd, u64 affinity, u32 config);
void __kbase_tlstream_tl_attrib_atom_priority(struct kbase_timeline *tl, void *atom, u32 prio);
void __kbase_tlstream_tl_attrib_atom_state(struct kbase_timeline *tl, void *atom, u32 state);
void __kbase_tlstream_tl_attrib_atom_prioritized(struct kbase_timeline *tl, void *atom);
void __kbase_tlstream_tl_attrib_atom_jit(struct kbase_timeline *tl,
	void *atom, u64 edit_addr, u64 new_addr,
	u64 va_pages, u64 jit_flags);
void __kbase_tlstream_tl_attrib_atom_jitallocinfo(struct kbase_timeline *tl,
	void *atom, u64 va_pages, u64 commit_pages, u64 extent,
	u32 jit_id, u32 bin_id, u32 max_allocations, u32 flags,
	u32 usage_id);
void __kbase_tlstream_tl_attrib_atom_jitfreeinfo(struct kbase_timeline *tl, void *atom, u32 jit_id);
void __kbase_tlstream_tl_attrib_as_config(struct kbase_timeline *tl,
	void *as, u64 transtab, u64 memattr, u64 transcfg);
void __kbase_tlstream_tl_event_atom_softstop_ex(struct kbase_timeline *tl, void *atom);
void __kbase_tlstream_tl_event_lpu_softstop(struct kbase_timeline *tl, void *lpu);
void __kbase_tlstream_tl_event_atom_softstop_issue(struct kbase_timeline *tl, void *atom);
void __kbase_tlstream_tl_event_atom_softjob_start(struct kbase_timeline *tl, void *atom);
void __kbase_tlstream_tl_event_atom_softjob_end(struct kbase_timeline *tl, void *atom);
void __kbase_tlstream_jd_gpu_soft_reset(struct kbase_timeline *tl, void *gpu);
void __kbase_tlstream_aux_pm_state(struct kbase_timeline *tl, u32 core_type, u64 state);
void __kbase_tlstream_aux_pagefault(struct kbase_timeline *tl, u32 ctx_nr, u32 as_nr, u64 page_count_change);
void __kbase_tlstream_aux_pagesalloc(struct kbase_timeline *tl, u32 ctx_nr, u64 page_count);
void __kbase_tlstream_aux_devfreq_target(struct kbase_timeline *tl, u64 target_freq);
void __kbase_tlstream_aux_protected_enter_start(struct kbase_timeline *tl, void *gpu);
void __kbase_tlstream_aux_protected_enter_end(struct kbase_timeline *tl, void *gpu);
void __kbase_tlstream_aux_protected_leave_start(struct kbase_timeline *tl, void *gpu);
void __kbase_tlstream_aux_protected_leave_end(struct kbase_timeline *tl, void *gpu);
void __kbase_tlstream_aux_jit_stats(struct kbase_timeline *tl, u32 ctx_nr, u32 bin_id,
	u32 max_allocations, u32 allocations,
	u32 va_pages_nr, u32 ph_pages_nr);
void __kbase_tlstream_aux_event_job_slot(struct kbase_timeline *tl,
	struct kbase_context *context, u32 slot_nr, u32 atom_nr, u32 event);

#define TLSTREAM_ENABLED (1 << 31)

#define __TRACE_IF_ENABLED(trace_name, kbdev, ...)                  \
	do {                                                        \
		int enabled = atomic_read(&kbdev->timeline_is_enabled); \
		typecheck(struct kbase_device *, kbdev);            \
		if (enabled & TLSTREAM_ENABLED)                     \
			__kbase_tlstream_##trace_name(kbdev->timeline, __VA_ARGS__); \
	} while (0)

#define __TRACE_IF_ENABLED_LATENCY(trace_name, kbdev, ...)              \
	do {                                                            \
		int enabled = atomic_read(&kbdev->timeline_is_enabled); \
		typecheck(struct kbase_device *, kbdev);                \
		if (enabled & BASE_TLSTREAM_ENABLE_LATENCY_TRACEPOINTS) \
			__kbase_tlstream_##trace_name(kbdev->timeline, __VA_ARGS__); \
	} while (0)

#define __TRACE_IF_ENABLED_JD(trace_name, kbdev, ...)               \
	do {                                                        \
		int enabled = atomic_read(&kbdev->timeline_is_enabled); \
		typecheck(struct kbase_device *, kbdev);            \
		if (enabled & BASE_TLSTREAM_JOB_DUMPING_ENABLED)    \
			__kbase_tlstream_##trace_name(kbdev->timeline, __VA_ARGS__); \
	} while (0)


/*****************************************************************************/

/* Gator tracepoints are hooked into TLSTREAM macro interface.
 * When the following tracepoints are called, corresponding
 * Gator tracepoint will be called as well.
 */
#if defined(CONFIG_MALI_GATOR_SUPPORT)

/* `event` is one of TL_JS_EVENT values here.
 * The values of TL_JS_EVENT are guaranteed to match
 * with corresponding GATOR_JOB_SLOT values.
 */
#define KBASE_TLSTREAM_AUX_EVENT_JOB_SLOT(kbdev, context, slot_nr, atom_nr, event) \
	do {                                                            \
		kbase_trace_mali_job_slots_event(kbdev->id,             \
			GATOR_MAKE_EVENT(event, slot_nr),               \
			context, (u8) atom_nr);                         \
		__TRACE_IF_ENABLED(aux_event_job_slot, kbdev, context, slot_nr, atom_nr, event); \
	} while (0)

#define KBASE_TLSTREAM_AUX_PM_STATE(kbdev, core_type, state)            \
	do {                                                            \
		kbase_trace_mali_pm_status(kbdev->id,                   \
			core_type, state);                              \
		__TRACE_IF_ENABLED(aux_pm_state, kbdev, core_type, state); \
	} while (0)


#define KBASE_TLSTREAM_AUX_PAGEFAULT(kbdev, ctx_nr, as_nr, page_count_change) \
	do {                                                            \
		kbase_trace_mali_page_fault_insert_pages(kbdev->id,     \
			as_nr,                                          \
			page_count_change);                             \
		__TRACE_IF_ENABLED(aux_pagefault, kbdev, ctx_nr, as_nr, page_count_change); \
	} while (0)

/* kbase_trace_mali_total_alloc_pages_change is handled differently here.
 * We stream the total amount of pages allocated for `kbdev` rather
 * than `page_count`, which is per-context.
 */
#define KBASE_TLSTREAM_AUX_PAGESALLOC(kbdev, ctx_nr, page_count) do {   \
		u32 global_pages_count = atomic_read(&kbdev->memdev.used_pages); \
		kbase_trace_mali_total_alloc_pages_change(kbdev->id,    \
			global_pages_count);                            \
		__TRACE_IF_ENABLED(aux_pagesalloc, kbdev, ctx_nr, page_count); \
	} while (0)


#endif

/*****************************************************************************/

/**
 * KBASE_TLSTREAM_TL_SUMMARY_NEW_CTX - create context object in timeline
 *                                     summary
 * @kbdev:   Kbase device
 * @context: Name of the context object
 * @nr:      Context number
 * @tgid:    Thread Group Id
 *
 * Function emits a timeline message informing about context creation. Context
 * is created with context number (its attribute), that can be used to link
 * kbase context with userspace context.
 * This message is directed to timeline summary stream.
 */
#define KBASE_TLSTREAM_TL_SUMMARY_NEW_CTX(kbdev, context, nr, tgid) \
	__TRACE_IF_ENABLED(tl_summary_new_ctx, kbdev, context, nr, tgid)

/**
 * KBASE_TLSTREAM_TL_SUMMARY_NEW_GPU - create GPU object in timeline summary
 * @kbdev:      Kbase device
 * @gpu:        Name of the GPU object
 * @id:         ID value of this GPU
 * @core_count: Number of cores this GPU hosts
 *
 * Function emits a timeline message informing about GPU creation. GPU is
 * created with two attributes: id and core count.
 * This message is directed to timeline summary stream.
 */
#define KBASE_TLSTREAM_TL_SUMMARY_NEW_GPU(kbdev, gpu, id, core_count) \
	__TRACE_IF_ENABLED(tl_summary_new_gpu, kbdev, gpu, id, core_count)

/**
 * KBASE_TLSTREAM_TL_SUMMARY_NEW_LPU - create LPU object in timeline summary
 * @kbdev: Kbase device
 * @lpu:   Name of the Logical Processing Unit object
 * @nr:    Sequential number assigned to this LPU
 * @fn:    Property describing this LPU's functional abilities
 *
 * Function emits a timeline message informing about LPU creation. LPU is
 * created with two attributes: number linking this LPU with GPU's job slot
 * and function bearing information about this LPU abilities.
 * This message is directed to timeline summary stream.
 */
#define KBASE_TLSTREAM_TL_SUMMARY_NEW_LPU(kbdev, lpu, nr, fn) \
	__TRACE_IF_ENABLED(tl_summary_new_lpu, kbdev, lpu, nr, fn)

/**
 * KBASE_TLSTREAM_TL_SUMMARY_LIFELINK_LPU_GPU - lifelink LPU object to GPU
 * @kbdev: Kbase device
 * @lpu:   Name of the Logical Processing Unit object
 * @gpu:   Name of the GPU object
 *
 * Function emits a timeline message informing that LPU object shall be deleted
 * along with GPU object.
 * This message is directed to timeline summary stream.
 */
#define KBASE_TLSTREAM_TL_SUMMARY_LIFELINK_LPU_GPU(kbdev, lpu, gpu) \
	__TRACE_IF_ENABLED(tl_summary_lifelink_lpu_gpu, kbdev, lpu, gpu)

/**
 * KBASE_TLSTREAM_TL_SUMMARY_NEW_AS - create address space object in timeline summary
 * @kbdev: Kbase device
 * @as: Name of the address space object
 * @nr: Sequential number assigned to this address space
 *
 * Function emits a timeline message informing about address space creation.
 * Address space is created with one attribute: number identifying this
 * address space.
 * This message is directed to timeline summary stream.
 */
#define KBASE_TLSTREAM_TL_SUMMARY_NEW_AS(kbdev, as, nr) \
	__TRACE_IF_ENABLED(tl_summary_new_as, kbdev, as, nr)

/**
 * KBASE_TLSTREAM_TL_SUMMARY_LIFELINK_AS_GPU - lifelink address space object to GPU
 * @kbdev: Kbase device
 * @as:    Name of the address space object
 * @gpu:   Name of the GPU object
 *
 * Function emits a timeline message informing that address space object
 * shall be deleted along with GPU object.
 * This message is directed to timeline summary stream.
 */
#define KBASE_TLSTREAM_TL_SUMMARY_LIFELINK_AS_GPU(kbdev, as, gpu) \
	__TRACE_IF_ENABLED(tl_summary_lifelink_as_gpu, kbdev, as, gpu)

/**
 * KBASE_TLSTREAM_TL_NEW_CTX - create context object in timeline
 * @kbdev:   Kbase device
 * @context: Name of the context object
 * @nr:      Context number
 * @tgid:    Thread Group Id
 *
 * Function emits a timeline message informing about context creation. Context
 * is created with context number (its attribute), that can be used to link
 * kbase context with userspace context.
 */
#define KBASE_TLSTREAM_TL_NEW_CTX(kbdev, context, nr, tgid) \
	__TRACE_IF_ENABLED(tl_new_ctx, kbdev, context, nr, tgid)

/**
 * KBASE_TLSTREAM_TL_NEW_ATOM - create atom object in timeline
 * @kbdev: Kbase device
 * @atom:  Name of the atom object
 * @nr:    Sequential number assigned to this atom
 *
 * Function emits a timeline message informing about atom creation. Atom is
 * created with atom number (its attribute) that links it with actual work
 * bucket id understood by hardware.
 */
#define KBASE_TLSTREAM_TL_NEW_ATOM(kbdev, atom, nr) \
	__TRACE_IF_ENABLED(tl_new_atom, kbdev, atom, nr)

/**
 * KBASE_TLSTREAM_TL_DEL_CTX - destroy context object in timeline
 * @kbdev:   Kbase device
 * @context: Name of the context object
 *
 * Function emits a timeline message informing that context object ceased to
 * exist.
 */
#define KBASE_TLSTREAM_TL_DEL_CTX(kbdev, context) \
	__TRACE_IF_ENABLED(tl_del_ctx, kbdev, context)

/**
 * KBASE_TLSTREAM_TL_DEL_ATOM - destroy atom object in timeline
 * @kbdev: Kbase device
 * @atom:  Name of the atom object
 *
 * Function emits a timeline message informing that atom object ceased to
 * exist.
 */
#define KBASE_TLSTREAM_TL_DEL_ATOM(kbdev, atom) \
	__TRACE_IF_ENABLED(tl_del_atom, kbdev, atom)

/**
 * KBASE_TLSTREAM_TL_RET_CTX_LPU - retain context by LPU
 * @kbdev:   Kbase device
 * @context: Name of the context object
 * @lpu:     Name of the Logical Processing Unit object
 *
 * Function emits a timeline message informing that context is being held
 * by LPU and must not be deleted unless it is released.
 */
#define KBASE_TLSTREAM_TL_RET_CTX_LPU(kbdev, context, lpu) \
	__TRACE_IF_ENABLED(tl_ret_ctx_lpu, kbdev, context, lpu)

/**
 * KBASE_TLSTREAM_TL_RET_ATOM_CTX - retain atom by context
 * @kbdev:   Kbase device
 * @atom:    Name of the atom object
 * @context: Name of the context object
 *
 * Function emits a timeline message informing that atom object is being held
 * by context and must not be deleted unless it is released.
 */
#define KBASE_TLSTREAM_TL_RET_ATOM_CTX(kbdev, atom, context) \
	__TRACE_IF_ENABLED(tl_ret_atom_ctx, kbdev, atom, context)

/**
 * KBASE_TLSTREAM_TL_RET_ATOM_LPU - retain atom by LPU
 * @kbdev:             Kbase device
 * @atom:              Name of the atom object
 * @lpu:               Name of the Logical Processing Unit object
 * @attrib_match_list: List containing match operator attributes
 *
 * Function emits a timeline message informing that atom object is being held
 * by LPU and must not be deleted unless it is released.
 */
#define KBASE_TLSTREAM_TL_RET_ATOM_LPU(kbdev, atom, lpu, attrib_match_list) \
	__TRACE_IF_ENABLED(tl_ret_atom_lpu, kbdev, atom, lpu, attrib_match_list)

/**
 * KBASE_TLSTREAM_TL_NRET_CTX_LPU - release context by LPU
 * @kbdev:   Kbase device
 * @context: Name of the context object
 * @lpu:     Name of the Logical Processing Unit object
 *
 * Function emits a timeline message informing that context is being released
 * by LPU object.
 */
#define KBASE_TLSTREAM_TL_NRET_CTX_LPU(kbdev, context, lpu) \
	__TRACE_IF_ENABLED(tl_nret_ctx_lpu, kbdev, context, lpu)

/**
 * KBASE_TLSTREAM_TL_NRET_ATOM_CTX - release atom by context
 * @kbdev:   Kbase device
 * @atom:    Name of the atom object
 * @context: Name of the context object
 *
 * Function emits a timeline message informing that atom object is being
 * released by context.
 */
#define KBASE_TLSTREAM_TL_NRET_ATOM_CTX(kbdev, atom, context) \
	__TRACE_IF_ENABLED(tl_nret_atom_ctx, kbdev, atom, context)

/**
 * KBASE_TLSTREAM_TL_NRET_ATOM_LPU - release atom by LPU
 * @kbdev: Kbase device
 * @atom:  Name of the atom object
 * @lpu:   Name of the Logical Processing Unit object
 *
 * Function emits a timeline message informing that atom object is being
 * released by LPU.
 */
#define KBASE_TLSTREAM_TL_NRET_ATOM_LPU(kbdev, atom, lpu) \
	__TRACE_IF_ENABLED(tl_nret_atom_lpu, kbdev, atom, lpu)

/**
 * KBASE_TLSTREAM_TL_RET_AS_CTX - lifelink address space object to context
 * @kbdev: Kbase device
 * @as:    Name of the address space object
 * @ctx:   Name of the context object
 *
 * Function emits a timeline message informing that address space object
 * is being held by the context object.
 */
#define KBASE_TLSTREAM_TL_RET_AS_CTX(kbdev, as, ctx) \
	__TRACE_IF_ENABLED(tl_ret_as_ctx, kbdev, as, ctx)

/**
 * KBASE_TLSTREAM_TL_NRET_AS_CTX - release address space by context
 * @kbdev: Kbase device
 * @as:    Name of the address space object
 * @ctx:   Name of the context object
 *
 * Function emits a timeline message informing that address space object
 * is being released by atom.
 */
#define KBASE_TLSTREAM_TL_NRET_AS_CTX(kbdev, as, ctx) \
	__TRACE_IF_ENABLED(tl_nret_as_ctx, kbdev, as, ctx)

/**
 * KBASE_TLSTREAM_TL_RET_ATOM_AS - retain atom by address space
 * @kbdev: Kbase device
 * @atom:  Name of the atom object
 * @as:    Name of the address space object
 *
 * Function emits a timeline message informing that atom object is being held
 * by address space and must not be deleted unless it is released.
 */
#define KBASE_TLSTREAM_TL_RET_ATOM_AS(kbdev, atom, as) \
	__TRACE_IF_ENABLED(tl_ret_atom_as, kbdev, atom, as)

/**
 * KBASE_TLSTREAM_TL_NRET_ATOM_AS - release atom by address space
 * @kbdev: Kbase device
 * @atom:  Name of the atom object
 * @as:    Name of the address space object
 *
 * Function emits a timeline message informing that atom object is being
 * released by address space.
 */
#define KBASE_TLSTREAM_TL_NRET_ATOM_AS(kbdev, atom, as) \
	__TRACE_IF_ENABLED(tl_nret_atom_as, kbdev, atom, as)

/**
 * KBASE_TLSTREAM_TL_ATTRIB_ATOM_CONFIG - atom job slot attributes
 * @kbdev:    Kbase device
 * @atom:     Name of the atom object
 * @jd:       Job descriptor address
 * @affinity: Job affinity
 * @config:   Job config
 *
 * Function emits a timeline message containing atom attributes.
 */
#define KBASE_TLSTREAM_TL_ATTRIB_ATOM_CONFIG(kbdev, atom, jd, affinity, config) \
	__TRACE_IF_ENABLED(tl_attrib_atom_config, kbdev, atom, jd, affinity, config)

/**
 * KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITY - atom priority
 * @kbdev: Kbase device
 * @atom:  Name of the atom object
 * @prio:  Atom priority
 *
 * Function emits a timeline message containing atom priority.
 */
#define KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITY(kbdev, atom, prio) \
	__TRACE_IF_ENABLED_LATENCY(tl_attrib_atom_priority, kbdev, atom, prio)

/**
 * KBASE_TLSTREAM_TL_ATTRIB_ATOM_STATE - atom state
 * @kbdev: Kbase device
 * @atom:  Name of the atom object
 * @state: Atom state
 *
 * Function emits a timeline message containing atom state.
 */
#define KBASE_TLSTREAM_TL_ATTRIB_ATOM_STATE(kbdev, atom, state) \
	__TRACE_IF_ENABLED_LATENCY(tl_attrib_atom_state, kbdev, atom, state)

/**
 * KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITIZED - atom was prioritized
 * @kbdev: Kbase device
 * @atom:  Name of the atom object
 *
 * Function emits a timeline message signalling priority change
 */
#define KBASE_TLSTREAM_TL_ATTRIB_ATOM_PRIORITIZED(kbdev, atom) \
	__TRACE_IF_ENABLED_LATENCY(tl_attrib_atom_prioritized, kbdev, atom)

/**
 * KBASE_TLSTREAM_TL_ATTRIB_ATOM_JIT - jit happened on atom
 * @kbdev:      Kbase device
 * @atom:       Atom identifier
 * @edit_addr:  Address edited by jit
 * @new_addr:   Address placed into the edited location
 * @va_pages:   Maximum number of pages this jit can allocate
 * @jit_flags:  Flags defining the properties of the memory region
 */
#define KBASE_TLSTREAM_TL_ATTRIB_ATOM_JIT(kbdev, atom, edit_addr, new_addr, \
		va_pages, jit_flags) \
	__TRACE_IF_ENABLED_JD(tl_attrib_atom_jit, kbdev, atom, edit_addr, \
		new_addr, va_pages, jit_flags)

/**
 * Information about the JIT allocation atom.
 *
 * @kbdev:           Kbase device
 * @atom:            Atom identifier.
 * @va_pages:        The minimum number of virtual pages required.
 * @commit_pages:    The minimum number of physical pages which
 *                   should back the allocation.
 * @extent:          Granularity of physical pages to grow the
 *                   allocation by during a fault.
 * @jit_id:          Unique ID provided by the caller, this is used
 *                   to pair allocation and free requests.
 * @bin_id:          The JIT allocation bin, used in conjunction with
 *                   @max_allocations to limit the number of each
 *                   type of JIT allocation.
 * @max_allocations: The maximum number of allocations allowed within
 *                   the bin specified by @bin_id. Should be the same
 *                   for all JIT allocations within the same bin.
 * @jit_flags:       Flags specifying the special requirements for
 *                   the JIT allocation.
 * @usage_id:        A hint about which allocation should be reused.
 *                   The kernel should attempt to use a previous
 *                   allocation with the same usage_id
 */
#define KBASE_TLSTREAM_TL_ATTRIB_ATOM_JITALLOCINFO(kbdev, atom, va_pages, \
		commit_pages, extent, jit_id, bin_id,\
		max_allocations, jit_flags, usage_id) \
	__TRACE_IF_ENABLED(tl_attrib_atom_jitallocinfo, kbdev, atom, va_pages, \
		commit_pages, extent, jit_id, bin_id,\
		max_allocations, jit_flags, usage_id)

/**
 * Information about the JIT free atom.
 *
 * @kbdev:  Kbase device
 * @atom:   Atom identifier.
 * @jit_id: Unique ID provided by the caller, this is used
 *          to pair allocation and free requests.
 */
#define KBASE_TLSTREAM_TL_ATTRIB_ATOM_JITFREEINFO(kbdev, atom, jit_id) \
	__TRACE_IF_ENABLED(tl_attrib_atom_jitfreeinfo, kbdev, atom, jit_id)

/**
 * KBASE_TLSTREAM_TL_ATTRIB_AS_CONFIG - address space attributes
 * @kbdev:    Kbase device
 * @as:       Assigned address space
 * @transtab: Configuration of the TRANSTAB register
 * @memattr:  Configuration of the MEMATTR register
 * @transcfg: Configuration of the TRANSCFG register (or zero if not present)
 *
 * Function emits a timeline message containing address space attributes.
 */
#define KBASE_TLSTREAM_TL_ATTRIB_AS_CONFIG(kbdev, as, transtab, memattr, transcfg) \
	__TRACE_IF_ENABLED(tl_attrib_as_config, kbdev, as, transtab, memattr, transcfg)

/**
 * KBASE_TLSTREAM_TL_EVENT_ATOM_SOFTSTOP_EX
 * @kbdev: Kbase device
 * @atom:  Atom identifier
 */
#define KBASE_TLSTREAM_TL_EVENT_ATOM_SOFTSTOP_EX(kbdev, atom) \
	__TRACE_IF_ENABLED(tl_event_atom_softstop_ex, kbdev, atom)

/**
 * KBASE_TLSTREAM_TL_EVENT_LPU_SOFTSTOP
 * @kbdev: Kbase device
 * @lpu:   Name of the LPU object
 */
#define KBASE_TLSTREAM_TL_EVENT_LPU_SOFTSTOP(kbdev, lpu) \
	__TRACE_IF_ENABLED(tl_event_lpu_softstop, kbdev, lpu)

/**
 * KBASE_TLSTREAM_TL_EVENT_ATOM_SOFTSTOP_ISSUE
 * @kbdev: Kbase device
 * @atom:  Atom identifier
 */
#define KBASE_TLSTREAM_TL_EVENT_ATOM_SOFTSTOP_ISSUE(kbdev, atom) \
	__TRACE_IF_ENABLED(tl_event_atom_softstop_issue, kbdev, atom)

/**
 * KBASE_TLSTREAM_TL_EVENT_ATOM_SOFTJOB_START
 * @kbdev: Kbase device
 * @atom:  Atom identifier
 */
#define KBASE_TLSTREAM_TL_EVENT_ATOM_SOFTJOB_START(kbdev, atom) \
	__TRACE_IF_ENABLED(tl_event_atom_softjob_start, kbdev, atom)

/**
 * KBASE_TLSTREAM_TL_EVENT_ATOM_SOFTJOB_END
 * @kbdev: Kbase device
 * @atom:  Atom identifier
 */
#define KBASE_TLSTREAM_TL_EVENT_ATOM_SOFTJOB_END(kbdev, atom) \
	__TRACE_IF_ENABLED(tl_event_atom_softjob_end, kbdev, atom)

/**
 * KBASE_TLSTREAM_JD_GPU_SOFT_RESET - The GPU is being soft reset
 * @kbdev: Kbase device
 * @gpu:   Name of the GPU object
 *
 * This imperative tracepoint is specific to job dumping.
 * Function emits a timeline message indicating GPU soft reset.
 */
#define KBASE_TLSTREAM_JD_GPU_SOFT_RESET(kbdev, gpu) \
	__TRACE_IF_ENABLED(jd_gpu_soft_reset, kbdev, gpu)


/**
 * KBASE_TLSTREAM_AUX_PM_STATE - timeline message: power management state
 * @kbdev:     Kbase device
 * @core_type: Core type (shader, tiler, l2 cache, l3 cache)
 * @state:     64bits bitmask reporting power state of the cores (1-ON, 0-OFF)
 */
#if !defined(KBASE_TLSTREAM_AUX_PM_STATE)
#define KBASE_TLSTREAM_AUX_PM_STATE(kbdev, core_type, state) \
	__TRACE_IF_ENABLED(aux_pm_state, kbdev, core_type, state)
#endif

/**
 * KBASE_TLSTREAM_AUX_PAGEFAULT - timeline message: MMU page fault event
 *                                resulting in new pages being mapped
 * @kbdev:             Kbase device
 * @ctx_nr:            Kernel context number
 * @as_nr:             Address space number
 * @page_count_change: Number of pages to be added
 */
#if !defined(KBASE_TLSTREAM_AUX_PAGEFAULT)
#define KBASE_TLSTREAM_AUX_PAGEFAULT(kbdev, ctx_nr, as_nr, page_count_change) \
	__TRACE_IF_ENABLED(aux_pagefault, kbdev, ctx_nr, as_nr, page_count_change)
#endif

/**
 * KBASE_TLSTREAM_AUX_PAGESALLOC - timeline message: total number of allocated
 *                                 pages is changed
 * @kbdev:      Kbase device
 * @ctx_nr:     Kernel context number
 * @page_count: Number of pages used by the context
 */
#if !defined(KBASE_TLSTREAM_AUX_PAGESALLOC)
#define KBASE_TLSTREAM_AUX_PAGESALLOC(kbdev, ctx_nr, page_count) \
	__TRACE_IF_ENABLED(aux_pagesalloc, kbdev, ctx_nr, page_count)
#endif

/**
 * KBASE_TLSTREAM_AUX_DEVFREQ_TARGET - timeline message: new target DVFS
 *                                     frequency
 * @kbdev:       Kbase device
 * @target_freq: New target frequency
 */
#define KBASE_TLSTREAM_AUX_DEVFREQ_TARGET(kbdev, target_freq) \
	__TRACE_IF_ENABLED(aux_devfreq_target, kbdev, target_freq)

/**
 * KBASE_TLSTREAM_AUX_PROTECTED_ENTER_START - The GPU has started transitioning
 *                                            to protected mode
 * @kbdev: Kbase device
 * @gpu:   Name of the GPU object
 *
 * Function emits a timeline message indicating the GPU is starting to
 * transition to protected mode.
 */
#define KBASE_TLSTREAM_AUX_PROTECTED_ENTER_START(kbdev, gpu) \
	__TRACE_IF_ENABLED_LATENCY(aux_protected_enter_start, kbdev, gpu)

/**
 * KBASE_TLSTREAM_AUX_PROTECTED_ENTER_END - The GPU has finished transitioning
 *                                          to protected mode
 * @kbdev: Kbase device
 * @gpu:   Name of the GPU object
 *
 * Function emits a timeline message indicating the GPU has finished
 * transitioning to protected mode.
 */
#define KBASE_TLSTREAM_AUX_PROTECTED_ENTER_END(kbdev, gpu) \
	__TRACE_IF_ENABLED_LATENCY(aux_protected_enter_end, kbdev, gpu)

/**
 * KBASE_TLSTREAM_AUX_PROTECTED_LEAVE_START - The GPU has started transitioning
 *                                            to non-protected mode
 * @kbdev: Kbase device
 * @gpu:   Name of the GPU object
 *
 * Function emits a timeline message indicating the GPU is starting to
 * transition to non-protected mode.
 */
#define KBASE_TLSTREAM_AUX_PROTECTED_LEAVE_START(kbdev, gpu) \
	__TRACE_IF_ENABLED_LATENCY(aux_protected_leave_start, kbdev, gpu)

/**
 * KBASE_TLSTREAM_AUX_PROTECTED_LEAVE_END - The GPU has finished transitioning
 *                                          to non-protected mode
 * @kbdev: Kbase device
 * @gpu:   Name of the GPU object
 *
 * Function emits a timeline message indicating the GPU has finished
 * transitioning to non-protected mode.
 */
#define KBASE_TLSTREAM_AUX_PROTECTED_LEAVE_END(kbdev, gpu) \
	__TRACE_IF_ENABLED_LATENCY(aux_protected_leave_end, kbdev, gpu)

/**
 * KBASE_TLSTREAM_AUX_JIT_STATS - JIT allocations per bin statistics
 *
 * @kbdev:      Kbase device
 * @ctx_nr:     Kernel context number
 * @bid:        JIT bin id
 * @max_allocs: Maximum allocations allowed in this bin.
 *              UINT_MAX is a special value. It denotes that
 *              the parameter was not changed since the last time.
 * @allocs:     Number of active allocations in this bin
 * @va_pages:   Number of virtual pages allocated in this bin
 * @ph_pages:   Number of physical pages allocated in this bin
 *
 * Function emits a timeline message indicating the JIT statistics
 * for a given bin have chaned.
 */
#define KBASE_TLSTREAM_AUX_JIT_STATS(kbdev, ctx_nr, bid, max_allocs, allocs, va_pages, ph_pages) \
	__TRACE_IF_ENABLED(aux_jit_stats, kbdev, ctx_nr, bid, \
			max_allocs, allocs, \
			va_pages, ph_pages)

/**
 * KBASE_TLSTREAM_AUX_EVENT_JOB_SLOT - An event has happened on a job slot
 *
 * @kbdev:      Kbase device
 * @context:    Kernel context pointer, NULL if event is not TL_JS_EVENT_START
 * @slot_nr:    Job slot number
 * @atom_nr:    Sequential number of an atom which has started
 *              execution on the job slot. Zero, if event is not TL_JS_EVENT_START.
 * @event:      Event type. One of TL_JS_EVENT values.
 */
#if !defined(KBASE_TLSTREAM_AUX_EVENT_JOB_SLOT)
#define KBASE_TLSTREAM_AUX_EVENT_JOB_SLOT(kbdev, context, slot_nr, atom_nr, event) \
	__TRACE_IF_ENABLED(aux_event_job_slot, kbdev, context, slot_nr, atom_nr, event)
#endif
#endif /* _KBASE_TLSTREAM_H */
